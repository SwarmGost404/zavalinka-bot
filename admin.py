from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, CallbackQueryHandler
import logging
from database import (
    init_db, get_db, add_song, get_all_songs, get_song_by_id,
    delete_song, update_song, search_by_title, search_by_text, get_songs_by_region
)
from env import ADMIN_API_TOKEN

# Initialize logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize database
init_db()

def parse_region(region_str):
    """Parse region string into category and place"""
    if region_str and '|' in region_str:
        parts = region_str.split('|')
        return parts[0], parts[1] if len(parts) > 1 else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    return region_str, "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"

async def show_song_details(update, song, edit_mode=False):
    """Show song details with ID and action buttons"""
    category, place = parse_region(song.region)
    
    response = (
        f"üéµ ID: {song.id}\n\n"
        f"üìù –ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}\n\n"
        f"üó∫Ô∏è –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}\n"
        f"üìç –ú–µ—Å—Ç–æ: {place}\n\n"
        f"üìú –¢–µ–∫—Å—Ç:\n{song.text[:300]}{'...' if len(song.text) > 300 else ''}"
    )
    
    if edit_mode:
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è –ù–∞–∑–≤–∞–Ω–∏–µ", callback_data="edit_title")],
            [InlineKeyboardButton("üåç –†–µ–≥–∏–æ–Ω", callback_data="edit_region")],
            [InlineKeyboardButton("üìù –¢–µ–∫—Å—Ç", callback_data="edit_text")],
            [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_edit")]
        ]
    else:
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit_{song.id}")],
            [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{song.id}")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back")]
        ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if isinstance(update, Update):
        await update.message.reply_text(response, reply_markup=reply_markup)
    else:
        await update.edit_message_text(response, reply_markup=reply_markup)

async def start(update: Update, context: CallbackContext) -> None:
    """Handler for /start command"""
    await update.message.reply_text(
        "üéµ –ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–∞—Ä–æ–¥–Ω—ã—Ö –ø–µ—Å–µ–Ω\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –ø–µ—Å–Ω—é\n"
        "/list - –°–ø–∏—Å–æ–∫ –ø–µ—Å–µ–Ω\n"
        "/search_title - –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é\n"
        "/search_text - –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É\n"
        "/search_region - –ü–æ–∏—Å–∫ –ø–æ —Ä–µ–≥–∏–æ–Ω—É\n"
        "/help - –ü–æ–º–æ—â—å"
    )

async def help_command(update: Update, context: CallbackContext) -> None:
    """Handler for /help command"""
    await update.message.reply_text(
        "üìñ –ü–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:\n\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–µ—Å–Ω—é\n"
        "/list - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –ø–µ—Å–Ω–∏ —Å ID\n"
        "/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Å–Ω—é\n"
        "/delete - –£–¥–∞–ª–∏—Ç—å –ø–µ—Å–Ω—é\n"
        "/search_title - –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é\n"
        "/search_text - –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É\n"
        "/search_region - –ü–æ–∏—Å–∫ –ø–æ —Ä–µ–≥–∏–æ–Ω—É"
    )

async def add_song_handler(update: Update, context: CallbackContext) -> None:
    """Handler for adding new song"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏:")
    context.user_data['state'] = 'awaiting_title'

async def list_songs_handler(update: Update, context: CallbackContext) -> None:
    """Handler for listing all songs with IDs"""
    db = next(get_db())
    try:
        songs = get_all_songs(db)
        if not songs:
            await update.message.reply_text("–í –±–∞–∑–µ –ø–æ–∫–∞ –Ω–µ—Ç –ø–µ—Å–µ–Ω.")
            return

        keyboard = []
        for song in songs:
            category, place = parse_region(song.region)
            btn_text = f"{song.id}: {song.title}"
            if place and place != "–Ω–µ —É–∫–∞–∑–∞–Ω–æ":
                btn_text += f" ({place})"
            keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"song_{song.id}")])
        
        await update.message.reply_text(
            "üìã –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Å–µ–Ω:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    except Exception as e:
        logger.error(f"Error listing songs: {e}")
        await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–µ—Å–µ–Ω")
    finally:
        db.close()

async def delete_song_handler(update: Update, context: CallbackContext) -> None:
    """Handler for deleting song by ID"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ ID –ø–µ—Å–Ω–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:")
    context.user_data['state'] = 'awaiting_song_id_for_delete'

async def edit_song_handler(update: Update, context: CallbackContext) -> None:
    """Handler for editing song"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ ID –ø–µ—Å–Ω–∏ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:")
    context.user_data['state'] = 'awaiting_song_id_for_edit'

async def search_title_handler(update: Update, context: CallbackContext) -> None:
    """Handler for searching by title"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    context.user_data['state'] = 'search_title'

async def search_text_handler(update: Update, context: CallbackContext) -> None:
    """Handler for searching by text"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    context.user_data['state'] = 'search_text'

async def search_region_handler(update: Update, context: CallbackContext) -> None:
    """Handler for searching by region"""
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    context.user_data['state'] = 'search_region'

async def handle_message(update: Update, context: CallbackContext) -> None:
    """Main message handler"""
    user_input = update.message.text
    user_state = context.user_data.get('state')

    if not user_state:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º")
        return

    try:
        if user_state == 'awaiting_title':
            context.user_data['title'] = user_input
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω (–∫–∞—Ç–µ–≥–æ—Ä–∏—è|–º–µ—Å—Ç–æ):")
            context.user_data['state'] = 'awaiting_region'

        elif user_state == 'awaiting_region':
            context.user_data['region'] = user_input
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏:")
            context.user_data['state'] = 'awaiting_text'

        elif user_state == 'awaiting_text':
            db = next(get_db())
            try:
                song = add_song(
                    db,
                    title=context.user_data['title'],
                    region=context.user_data['region'],
                    text=user_input
                )
                await update.message.reply_text(
                    f"‚úÖ –ü–µ—Å–Ω—è –¥–æ–±–∞–≤–ª–µ–Ω–∞!\nID: {song.id}\n"
                    f"–ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}\n–†–µ–≥–∏–æ–Ω: {song.region}"
                )
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data.clear()

        elif user_state == 'awaiting_song_id_for_delete':
            try:
                song_id = int(user_input)
                db = next(get_db())
                if delete_song(db, song_id):
                    await update.message.reply_text(f"‚úÖ –ü–µ—Å–Ω—è —Å ID {song_id} —É–¥–∞–ª–µ–Ω–∞")
                else:
                    await update.message.reply_text(f"‚ùå –ü–µ—Å–Ω—è —Å ID {song_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            except ValueError:
                await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data.clear()

        elif user_state == 'awaiting_song_id_for_edit':
            try:
                song_id = int(user_input)
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if song:
                    context.user_data['song_id'] = song_id
                    await show_song_details(update, song, edit_mode=True)
                else:
                    await update.message.reply_text(f"‚ùå –ü–µ—Å–Ω—è —Å ID {song_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            except ValueError:
                await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞: {str(e)}")
            finally:
                db.close()

        elif user_state.startswith('editing_'):
            field = user_state.split('_')[1]
            song_id = context.user_data.get('song_id')
            
            if not song_id:
                await update.message.reply_text("–°–µ—Å—Å–∏—è —É—Ç–µ—Ä—è–Ω–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ")
                context.user_data.clear()
                return
                
            db = next(get_db())
            try:
                update_data = {field: user_input}
                updated_song = update_song(db, song_id, **update_data)
                
                if updated_song:
                    await update.message.reply_text(f"‚úÖ {field.capitalize()} —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!")
                    await show_song_details(update, updated_song, edit_mode=True)
                else:
                    await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data['state'] = 'edit_menu'

        elif user_state == 'search_title':
            db = next(get_db())
            try:
                songs = search_by_title(db, user_input)
                await display_search_results(update, songs, "–ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data.clear()

        elif user_state == 'search_text':
            db = next(get_db())
            try:
                songs = search_by_text(db, user_input)
                await display_search_results(update, songs, "–ø–æ —Ç–µ–∫—Å—Ç—É")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data.clear()

        elif user_state == 'search_region':
            db = next(get_db())
            try:
                songs = get_songs_by_region(db, user_input)
                await display_search_results(update, songs, "–ø–æ —Ä–µ–≥–∏–æ–Ω—É")
            except Exception as e:
                await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {str(e)}")
            finally:
                db.close()
                context.user_data.clear()

    except Exception as e:
        logger.error(f"Error in handle_message: {e}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
        context.user_data.clear()

async def display_search_results(update: Update, songs, search_type):
    """Display search results with IDs"""
    if not songs:
        await update.message.reply_text(f"–ü–æ –∑–∞–ø—Ä–æ—Å—É {search_type} –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return
    
    keyboard = []
    for song in songs:
        category, place = parse_region(song.region)
        btn_text = f"{song.id}: {song.title}"
        if place and place != "–Ω–µ —É–∫–∞–∑–∞–Ω–æ":
            btn_text += f" ({place})"
        keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"song_{song.id}")])
    
    await update.message.reply_text(
        f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ {search_type}:",
        reply_markup=InlineKeyboardMarkup(keyboard)
)

async def button_callback(update: Update, context: CallbackContext) -> None:
    """Handler for inline buttons"""
    query = update.callback_query
    await query.answer()

    try:
        if query.data.startswith("song_"):
            song_id = int(query.data.split("_")[1])
            db = next(get_db())
            try:
                song = get_song_by_id(db, song_id)
                if song:
                    await show_song_details(query, song)
                else:
                    await query.edit_message_text("‚ùå –ü–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            finally:
                db.close()

        elif query.data.startswith("edit_"):
            field = query.data.split("_")[1]
            context.user_data['state'] = f'editing_{field}'
            await query.edit_message_text(f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {field}:")
        
        elif query.data.startswith("delete_"):
            song_id = int(query.data.split("_")[1])
            db = next(get_db())
            try:
                song = get_song_by_id(db, song_id)
                if song:
                    context.user_data['song_to_delete'] = {
                        'id': song_id,
                        'title': song.title
                    }
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data="confirm_delete")],
                        [InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_delete")]
                    ]
                    await query.edit_message_text(
                        f"‚ö†Ô∏è –£–¥–∞–ª–∏—Ç—å –ø–µ—Å–Ω—é?\nID: {song_id}\n–ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}",
                        reply_markup=InlineKeyboardMarkup(keyboard))
            finally:
                db.close()

        elif query.data == "confirm_delete":
            if 'song_to_delete' not in context.user_data:
                await query.edit_message_text("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
                return
            
            song_id = context.user_data['song_to_delete']['id']
            db = next(get_db())
            try:
                if delete_song(db, song_id):
                    await query.edit_message_text(
                        f"‚úÖ –ü–µ—Å–Ω—è —É–¥–∞–ª–µ–Ω–∞:\n"
                        f"ID: {song_id}\n"
                        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {context.user_data['song_to_delete']['title']}"
                    )
                else:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏")
            finally:
                db.close()
                context.user_data.clear()

        elif query.data in ["cancel_edit", "cancel_delete", "back"]:
            await query.delete_message()
            context.user_data.clear()

    except ValueError:
        await query.edit_message_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–µ—Å–Ω–∏")
    except Exception as e:
        logger.error(f"Error in button_callback: {e}")
        await query.edit_message_text("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
        context.user_data.clear()

def main() -> None:
    """Start the bot."""
    application = Application.builder().token(ADMIN_API_TOKEN).build()

    # Register command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_song_handler))
    application.add_handler(CommandHandler("list", list_songs_handler))
    application.add_handler(CommandHandler("delete", delete_song_handler))
    application.add_handler(CommandHandler("edit", edit_song_handler))
    application.add_handler(CommandHandler("search_title", search_title_handler))
    application.add_handler(CommandHandler("search_text", search_text_handler))
    application.add_handler(CommandHandler("search_region", search_region_handler))

    # Register message handler
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Register callback handler
    application.add_handler(CallbackQueryHandler(button_callback))

    # Run the bot
    application.run_polling()

if __name__ == '__main__':
    main()