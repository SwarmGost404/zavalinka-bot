import logging
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    BotCommand,
    MenuButtonCommands
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackContext,
    CallbackQueryHandler,
    ContextTypes
)
from env import ADMIN_API_TOKEN
from database import (
    init_db,
    get_db,
    add_song,
    get_all_songs,
    get_all_songs_with_id,
    get_songs_by_region,
    search_by_title,
    search_by_text,
    get_song_by_id,
    delete_song,
    update_song
)

# Initialize logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize database
init_db()

def parse_region(region_str):
    """Parse region string into category and place"""
    if '|' in region_str:
        parts = region_str.split('|')
        return parts[0], parts[1] if len(parts) > 1 else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    return region_str, "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"

async def setup_commands(application: Application):
    """Set up the bot commands for the menu"""
    commands = [
        BotCommand("start", "–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º"),
        BotCommand("add", "–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–µ—Å–Ω—é"),
        BotCommand("search_title", "–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é"),
        BotCommand("search_text", "–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É"),
        BotCommand("search_place", "–ü–æ–∏—Å–∫ –ø–æ –º–µ—Å—Ç—É"),
        BotCommand("all", "–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Å–µ–Ω"),
        BotCommand("edit", "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Å–Ω—é"),
        BotCommand("delete", "–£–¥–∞–ª–∏—Ç—å –ø–µ—Å–Ω—é"),
        BotCommand("help", "–ü–æ–º–æ—â—å –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏")
    ]
    await application.bot.set_my_commands(commands)
    await application.bot.set_chat_menu_button(menu_button=MenuButtonCommands())

async def start(update: Update, context: CallbackContext) -> None:
    help_text = (
        "üéµ –≠—Ç–Ω–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∞—Ä—Ö–∏–≤ –ø–µ—Å–µ–Ω\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–µ—Å–Ω—é\n"
        "/search_title - –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é\n"
        "/search_text - –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É\n"
        "/search_place - –ü–æ–∏—Å–∫ –ø–æ –º–µ—Å—Ç—É\n"
        "/all - –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Å–µ–Ω\n"
        "/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Å–Ω—é\n"
        "/delete - –£–¥–∞–ª–∏—Ç—å –ø–µ—Å–Ω—é\n"
        "/help - –ü–æ–º–æ—â—å –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –∏–∑ –º–µ–Ω—é –∏–ª–∏ –≤–≤–æ–¥–∏—Ç–µ –≤—Ä—É—á–Ω—É—é"
    )
    await update.message.reply_text(help_text)

async def help_command(update: Update, context: CallbackContext) -> None:
    help_text = (
        "üéµ –≠—Ç–Ω–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∞—Ä—Ö–∏–≤ –ø–µ—Å–µ–Ω\n\n"
        "–°–≤—è–∑—å —Å —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º: @SwarmGost\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n\n"
        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–µ—Å–Ω—é\n"
        "/search_title - –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é\n"
        "/search_text - –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É\n"
        "/search_place - –ü–æ–∏—Å–∫ –ø–æ –º–µ—Å—Ç—É\n"
        "/all - –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Å–µ–Ω\n"
        "/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Å–Ω—é\n"
        "/delete - –£–¥–∞–ª–∏—Ç—å –ø–µ—Å–Ω—é\n"
        "/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
        "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –º–µ–Ω—é –≤–Ω–∏–∑—É —Å–ª–µ–≤–∞, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –≤—Å–µ –∫–æ–º–∞–Ω–¥—ã"
    )
    await update.message.reply_text(help_text)

async def add_song_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏:')
    context.user_data['state'] = 'awaiting_title'
    context.user_data['action'] = 'add'

async def search_title_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞:')
    context.user_data['state'] = 'search_title'

async def search_text_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞:')
    context.user_data['state'] = 'search_text'

async def search_place_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ –º–µ—Å—Ç–æ –∑–∞–ø–∏—Å–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞:')
    context.user_data['state'] = 'search_place'

async def list_songs_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    db = next(get_db())
    try:
        songs = get_all_songs(db)
        if not songs:
            await update.message.reply_text("–í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞ –Ω–µ—Ç –ø–µ—Å–µ–Ω.")
            return

        keyboard = []
        for song in songs:
            category, place = parse_region(song.region)
            button_text = f"{song.title}"
            if place and place != "–Ω–µ —É–∫–∞–∑–∞–Ω–æ":
                button_text += f" ({place})"
            
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"song_{song.id}")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Å–µ–Ω:",
            reply_markup=reply_markup
        )
            
    except Exception as e:
        logger.error(f"Error in list_songs: {e}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–µ—Å–µ–Ω.")
    finally:
        db.close()

async def update_song_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ ID –ø–µ—Å–Ω–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:")
    context.user_data['state'] = 'awaiting_song_id_for_update'
    context.user_data['action'] = 'update'

async def delete_song_handler(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ ID –ø–µ—Å–Ω–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:")
    context.user_data['state'] = 'awaiting_song_id_for_delete'
    context.user_data['action'] = 'delete'

async def confirm_delete(update: Update, context: CallbackContext) -> None:
    if 'song_to_delete' not in context.user_data:
        await update.message.reply_text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
        return
    
    db = None
    try:
        db = next(get_db())
        song_id = context.user_data['song_to_delete']['id']
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
        song = get_song_by_id(db, song_id)
        if not song:
            await update.message.reply_text(f"–ü–µ—Å–Ω—è —Å ID {song_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
            
        # –£–¥–∞–ª—è–µ–º –ø–µ—Å–Ω—é
        delete_song(db, song_id)
        
        await update.message.reply_text(
            f"–ü–µ—Å–Ω—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!\n"
            f"ID: {song_id}\n"
            f"–ù–∞–∑–≤–∞–Ω–∏–µ: {context.user_data['song_to_delete']['title']}\n"
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏")
    finally:
        if db:
            db.close()
        context.user_data.clear()

async def cancel_action(update: Update, context: CallbackContext) -> None:
    if 'action' in context.user_data:
        await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ")
    context.user_data.clear()
    await start(update, context)

async def show_song_details(update, song, edit_mode=False):
    """–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏ –ø–µ—Å–Ω–∏ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–µ–π—Å—Ç–≤–∏–π"""
    if '|' in song.region:
        category, place = song.region.split('|', 1)
    else:
        category, place = song.region, "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    
    response_text = f"ID: {song.id}\n\n"
    response_text += f"–ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}\n\n"
    response_text += f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}\n\n"
    response_text += f"–ú–µ—Å—Ç–æ –∑–∞–ø–∏—Å–∏: {place}\n\n"
    response_text += f"–¢–µ–∫—Å—Ç:\n{song.text[:200]}..." if len(song.text) > 200 else f"–¢–µ–∫—Å—Ç:\n{song.text}"
    
    if edit_mode:
        keyboard = [
            [InlineKeyboardButton("–ù–∞–∑–≤–∞–Ω–∏–µ", callback_data="edit_title")],
            [InlineKeyboardButton("–†–µ–≥–∏–æ–Ω –∏ –º–µ—Å—Ç–æ", callback_data="edit_region")],
            [InlineKeyboardButton("–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏", callback_data="edit_text")],
            [InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="cancel_edit")]
        ]
    else:
        keyboard = [
            [InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit_{song.id}")],
            [InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{song.id}")],
            [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="back")]
        ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if isinstance(update, Update):  # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await update.message.reply_text(response_text, reply_markup=reply_markup)
    else:  # –ï—Å–ª–∏ –ø—Ä–∏—à–µ–ª callback query
        await update.edit_message_text(response_text, reply_markup=reply_markup)

async def handle_message(update: Update, context: CallbackContext) -> None:
    user_input = update.message.text
    user_state = context.user_data.get('state')

    if not user_state:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–æ—Ç–æ–º. /help - –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥")
        return

    try:
        if user_state == 'awaiting_title':
            context.user_data['title'] = user_input
            await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:')
            context.user_data['state'] = 'awaiting_region'

        elif user_state == 'awaiting_region':
            context.user_data['region'] = user_input
            await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ –º–µ—Å—Ç–æ –∑–∞–ø–∏—Å–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–°–µ–ª–æ –í—è—Ç—Å–∫–æ–µ –Ø—Ä–æ—Å–ª–∞–≤—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏"):')
            context.user_data['state'] = 'awaiting_place'

        elif user_state == 'awaiting_place':
            context.user_data['place'] = user_input
            await update.message.reply_text('–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏:')
            context.user_data['state'] = 'awaiting_text'

        elif user_state == 'awaiting_text':
            context.user_data['text'] = user_input
            await save_song(update, context)

        elif user_state == 'search_title':
            db = next(get_db())
            results = search_by_title(db, user_input)
            await display_results(update, results, f"–ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é '{user_input}'", context)

        elif user_state == 'search_text':
            db = next(get_db())
            results = search_by_text(db, user_input)
            await display_results(update, results, f"–ø–æ —Ç–µ–∫—Å—Ç—É '{user_input}'", context)

        elif user_state == 'search_place':
            db = next(get_db())
            results = [song for song in get_all_songs(db) 
                      if '|' in song.region and user_input.lower() in song.region.lower().split('|')[1]]
            await display_results(update, results, f"–ø–æ –º–µ—Å—Ç—É –∑–∞–ø–∏—Å–∏ '{user_input}'", context)

        elif user_state == 'awaiting_song_id_for_update':
            try:
                song_id = int(user_input)
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if not song:
                    await update.message.reply_text(f"–ü–µ—Å–Ω—è —Å ID {song_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                    context.user_data.clear()
                    return

                context.user_data['song_id'] = song_id
                context.user_data['current_song'] = {
                    'title': song.title,
                    'region': song.region,
                    'text': song.text
                }
                
                await show_song_details(update, song, edit_mode=True)
                
            except ValueError:
                await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
                context.user_data.clear()

        elif user_state == 'awaiting_song_id_for_delete':
            try:
                song_id = int(user_input)
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if not song:
                    await update.message.reply_text(f"–ü–µ—Å–Ω—è —Å ID {song_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                    context.user_data.clear()
                    return
                
                context.user_data['song_to_delete'] = {
                    'id': song_id,
                    'title': song.title,
                    'region': song.region
                }
                
                keyboard = [
                    [InlineKeyboardButton("–î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data="confirm_delete")],
                    [InlineKeyboardButton("–ù–µ—Ç, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_delete")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await update.message.reply_text(
                    f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —É–¥–∞–ª–µ–Ω–∏–µ:\n\n"
                    f"ID: {song_id}\n"
                    f"–ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}\n"
                    f"–†–µ–≥–∏–æ–Ω: {song.region}\n\n"
                    f"–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–ø–∏—Å—å?",
                    reply_markup=reply_markup
                )
            except ValueError:
                await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
                context.user_data.clear()

        elif user_state == 'editing_title':
            if 'song_id' not in context.user_data:
                await update.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID –ø–µ—Å–Ω–∏")
                context.user_data.clear()
                return
                
            song_id = context.user_data['song_id']
            db = next(get_db())
            try:
                update_song(db, song_id, title=user_input)
                await update.message.reply_text(f"–ù–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: {user_input}")
                
                if 'current_song' in context.user_data:
                    context.user_data['current_song']['title'] = user_input
                    
                song = get_song_by_id(db, song_id)
                await show_song_details(update, song, edit_mode=True)
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏—è: {e}")
                await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏")
            finally:
                db.close()
                
        elif user_state == 'editing_region':
            if 'song_id' not in context.user_data:
                await update.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID –ø–µ—Å–Ω–∏")
                context.user_data.clear()
                return
                
            if '|' not in user_input or not user_input.split('|')[0].strip():
                await update.message.reply_text(
                    "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –∫–∞–∫: –ö–∞—Ç–µ–≥–æ—Ä–∏—è|–ú–µ—Å—Ç–æ\n\n"
                    "–ü—Ä–∏–º–µ—Ä—ã:\n"
                    "–†—É—Å—Å–∫–∏–µ –Ω–∞—Ä–æ–¥–Ω—ã–µ|–î–µ—Ä–µ–≤–Ω—è –ü–µ—Ç—Ä–æ–≤–∫–∞\n"
                    "–ö–∞–∑–∞—á—å–∏|–°—Ç–∞–Ω–∏—Ü–∞ –í–µ—à–µ–Ω—Å–∫–∞—è\n"
                    "–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ|–ì–æ—Ä–æ–¥ –ú–æ—Å–∫–≤–∞"
                )
                return
                
            song_id = context.user_data['song_id']
            db = next(get_db())
            try:
                update_song(db, song_id, region=user_input)
                await update.message.reply_text("–†–µ–≥–∏–æ–Ω –∏ –º–µ—Å—Ç–æ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!")
                
                if 'current_song' in context.user_data:
                    context.user_data['current_song']['region'] = user_input
                    
                song = get_song_by_id(db, song_id)
                await show_song_details(update, song, edit_mode=True)
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ä–µ–≥–∏–æ–Ω–∞: {e}")
                await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏")
            finally:
                db.close()
                context.user_data['state'] = 'edit_menu'
                
        elif user_state == 'editing_text':
            if 'song_id' not in context.user_data:
                await update.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID –ø–µ—Å–Ω–∏")
                context.user_data.clear()
                return
                
            song_id = context.user_data['song_id']
            db = next(get_db())
            try:
                update_song(db, song_id, text=user_input)
                await update.message.reply_text("–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω")
                
                if 'current_song' in context.user_data:
                    context.user_data['current_song']['text'] = user_input
                    
                song = get_song_by_id(db, song_id)
                await show_song_details(update, song, edit_mode=True)
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞: {e}")
                await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏")
            finally:
                db.close()

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        context.user_data.clear()

async def save_song(update: Update, context: CallbackContext) -> None:
    db = next(get_db())
    try:
        title = context.user_data['title']
        region = context.user_data['region']
        place = context.user_data.get('place', '')
        text = context.user_data.get('text', '')
        
        full_region = f"{region}|{place}"
        
        song = add_song(db, title=title, region=full_region, text=text)
        await update.message.reply_text(
            f'–ü–µ—Å–Ω—è "{title}" —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n'
            f'–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {region}\n'
            f'–ú–µ—Å—Ç–æ –∑–∞–ø–∏—Å–∏: {place}\n'
        )
        context.user_data.clear()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        context.user_data.clear()
    finally:
        db.close()

async def display_results(update: Update, results, search_description, context: CallbackContext):
    if results:
        keyboard = []
        for song in results:
            category, place = parse_region(song.region)
            button_text = f"ID: {song.id} - {song.title}"
            if place and place != "–Ω–µ —É–∫–∞–∑–∞–Ω–æ":
                button_text += f" ({place})"
            
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"song_{song.id}")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            f"–ù–∞–π–¥–µ–Ω—ã –ø–µ—Å–Ω–∏ {search_description}:",
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(f"–ü–æ –∑–∞–ø—Ä–æ—Å—É {search_description} –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

async def button_callback(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    
    db = None  # Initialize db outside try block
    try:
        if query.data.startswith("song_"):
            try:
                song_id = int(query.data.split("_")[1])
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if song:
                    await show_song_details(query, song)
                else:
                    await query.edit_message_text("–ü–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            except (ValueError, IndexError):
                await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–µ—Å–Ω–∏")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}")
                await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
                
        elif query.data.startswith("edit_"):
            try:
                song_id = int(query.data.split("_")[1])
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if song:
                    context.user_data.update({
                        'song_id': song_id,
                        'current_song': {
                            'title': song.title,
                            'region': song.region,
                            'text': song.text
                        },
                        'state': 'edit_menu'
                    })
                    await show_song_details(query, song, edit_mode=True)
                else:
                    await query.edit_message_text("–ü–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            except (ValueError, IndexError):
                await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–µ—Å–Ω–∏")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}")
                await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
                
        elif query.data.startswith("delete_"):
            try:
                song_id = int(query.data.split("_")[1])
                db = next(get_db())
                song = get_song_by_id(db, song_id)
                if song:
                    context.user_data['song_to_delete'] = {
                        'id': song_id,
                        'title': song.title,
                        'region': song.region
                    }
                    
                    keyboard = [
                        [InlineKeyboardButton("–î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data="confirm_delete")],
                        [InlineKeyboardButton("–ù–µ—Ç, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_delete")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(
                        f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —É–¥–∞–ª–µ–Ω–∏–µ:\n\n"
                        f"ID: {song_id}\n"
                        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {song.title}\n"
                        f"–†–µ–≥–∏–æ–Ω: {song.region}\n\n"
                        f"–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–ø–∏—Å—å?",
                        reply_markup=reply_markup
                    )
                else:
                    await query.edit_message_text("–ü–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            except (ValueError, IndexError):
                await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–µ—Å–Ω–∏")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}")
                await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
                
        elif query.data in ["edit_title", "edit_region", "edit_text"]:
            context.user_data['state'] = f'editing_{query.data.split("_")[1]}'
            if query.data == "edit_region":
                await query.edit_message_text(
                    "–í–≤–µ–¥–∏—Ç–µ —Ä–µ–≥–∏–æ–Ω –∏ –º–µ—Å—Ç–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –ö–∞—Ç–µ–≥–æ—Ä–∏—è|–ú–µ—Å—Ç–æ\n\n"
                    "–ü—Ä–∏–º–µ—Ä—ã:\n"
                    "–†—É—Å—Å–∫–∏–µ –Ω–∞—Ä–æ–¥–Ω—ã–µ|–î–µ—Ä–µ–≤–Ω—è –ü–µ—Ç—Ä–æ–≤–∫–∞\n"
                    "–ö–∞–∑–∞—á—å–∏|–°—Ç–∞–Ω–∏—Ü–∞ –í–µ—à–µ–Ω—Å–∫–∞—è\n"
                    "–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ|–ì–æ—Ä–æ–¥ –ú–æ—Å–∫–≤–∞"
                )
            else:
                await query.edit_message_text(f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π {query.data.split('_')[1]} –ø–µ—Å–Ω–∏:")
            
        elif query.data == "confirm_delete":
            if 'song_to_delete' not in context.user_data:
                await query.edit_message_text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
                return
            
            try:
                db = next(get_db())
                song_id = context.user_data['song_to_delete']['id']
                delete_song(db, song_id)
                await query.edit_message_text(
                    f"–ü–µ—Å–Ω—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!\n"
                    f"ID: {song_id}\n"
                    f"–ù–∞–∑–≤–∞–Ω–∏–µ: {context.user_data['song_to_delete']['title']}"
                )
                context.user_data.clear()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–µ—Å–Ω–∏: {e}")
                await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏")
                
        elif query.data in ["cancel_edit", "cancel_delete", "back"]:
            await query.delete_message()
            context.user_data.clear()
            
        else:
            await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
            logger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ callback –¥–∞–Ω–Ω—ã–µ: {query.data}")
            
    except Exception as e:
        logger.error(f"–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ button_callback: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞")
        
    finally:
        if db is not None:
            db.close()

def main() -> None:
    """Start the bot."""
    application = Application.builder().token(ADMIN_API_TOKEN).build()

    # Register command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_song_handler))
    application.add_handler(CommandHandler("search_title", search_title_handler))
    application.add_handler(CommandHandler("search_text", search_text_handler))
    application.add_handler(CommandHandler("search_place", search_place_handler))
    application.add_handler(CommandHandler("all", list_songs_handler))
    application.add_handler(CommandHandler("edit", update_song_handler))
    application.add_handler(CommandHandler("delete", delete_song_handler))

    # Register message handler
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Register callback handler
    application.add_handler(CallbackQueryHandler(button_callback))

    # Set up commands menu
    application.post_init = setup_commands

    # Run the bot
    application.run_polling()

if __name__ == '__main__':
    main()